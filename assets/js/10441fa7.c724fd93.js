"use strict";(self.webpackChunkcatenax_ng=self.webpackChunkcatenax_ng||[]).push([[7187],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>d});var a=n(7294);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,s=function(e,t){if(null==e)return{};var n,a,s={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},m=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,s=e.mdxType,r=e.originalType,l=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),u=p(n),d=s,h=u["".concat(l,".").concat(d)]||u[d]||c[d]||r;return n?a.createElement(h,i(i({ref:t},m),{},{components:n})):a.createElement(h,i({ref:t},m))}));function d(e,t){var n=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var r=n.length,i=new Array(r);i[0]=u;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:s,i[1]=o;for(var p=2;p<r;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},8183:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>c,frontMatter:()=>r,metadata:()=>o,toc:()=>p});var a=n(7462),s=(n(7294),n(3905));const r={title:"How to use persistent storage"},i=void 0,o={unversionedId:"guides/how-to-use-persistent-storage",id:"guides/how-to-use-persistent-storage",title:"How to use persistent storage",description:"This is a short guide on how to create persistent storage on Kubernetes clusters.",source:"@site/docs/guides/how-to-use-persistent-storage.md",sourceDirName:"guides",slug:"/guides/how-to-use-persistent-storage",permalink:"/docs/guides/how-to-use-persistent-storage",draft:!1,editUrl:"https://github.com/catenax-ng/catenax-ng.github.io/edit/main/docs/guides/how-to-use-persistent-storage.md",tags:[],version:"current",frontMatter:{title:"How to use persistent storage"},sidebar:"tutorialSidebar",previous:{title:"How to use Two-Factor Authentication (2FA) with GitHub.com",permalink:"/docs/guides/how-to-use-2fa-with-github"},next:{title:"How To Use HashiCorp Vault",permalink:"/docs/guides/how-to-use-vault"}},l={},p=[{value:"Basic information",id:"basic-information",level:2},{value:"Examples",id:"examples",level:2},{value:"Defining persistent volume claim for deployment",id:"defining-persistent-volume-claim-for-deployment",level:3},{value:"Persistent volumes in statefulSet(s)",id:"persistent-volumes-in-statefulsets",level:3},{value:"Defining dependencies that use persistent volume claims",id:"defining-dependencies-that-use-persistent-volume-claims",level:3},{value:"Defining persistent volume claims",id:"defining-persistent-volume-claims",level:3},{value:"Configuring storage",id:"configuring-storage",level:3}],m={toc:p};function c(e){let{components:t,...n}=e;return(0,s.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This is a short guide on how to create persistent storage on Kubernetes clusters."),(0,s.kt)("h2",{id:"basic-information"},"Basic information"),(0,s.kt)("p",null,"By default Kubernetes stores data for pods on the storage of the nodes the pods are started on. This presents various potential issues in terms of capacity, data retention, and security. Your application, and/or its dependency might need to store data in a persistent way. Kubernetes offers a simple to use solution for that in the form of persistent volumes."),(0,s.kt)("p",null,"One scenario is that your own application uses persistent storage. In this case you need to include the storage definition in the StatefulSet, Deployment or Pod."),(0,s.kt)("p",null,"The other use case is that you define one or more dependencies for your application, that require persistent storage, in which case the helm chart, that is a dependency, will have the storage defined in a similar way."),(0,s.kt)("admonition",{type:"tip"},(0,s.kt)("p",{parentName:"admonition"},"You can both define persistent storage for your application, and use dependencies that also define such resource needs, at the same time.")),(0,s.kt)("p",null,"In both cases, all the rest will be taken care of by the Kubernetes engine and storage driver, creating the necessary resources in the Kubernetes cluster, and on the underlying cloud platform, ",(0,s.kt)("strong",{parentName:"p"},"you only need to define a persistent volume claim in your pod, or deployment, a volume claim template for statefulset"),"."),(0,s.kt)("h2",{id:"examples"},"Examples"),(0,s.kt)("h3",{id:"defining-persistent-volume-claim-for-deployment"},"Defining persistent volume claim for deployment"),(0,s.kt)("p",null,"To directly attach persistent storage to your deployment or pod, you will need a persistentVolumeClaim type resource, and add volume(s) to your deployment."),(0,s.kt)("p",null,"persistentVolumeClaim.yaml:"),(0,s.kt)("admonition",{type:"tip"},(0,s.kt)("p",{parentName:"admonition"},"The persistentVolumeClaim.yaml can be omitted if ",(0,s.kt)("strong",{parentName:"p"},"dynamic provisioning"),' is enabled, i.e. no storageClassName is defined, only the pod or deployment is needed with the storage configuration in its definition.\nIf storageClassName is set to "-", storageClassName: "", dynamic provisioning is disabled, in this case you need to define your own persistentVolumeClaim.')),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-yaml"},"kind: PersistentVolumeClaim\napiVersion: v1\nmetadata:\n  name: pvc-persistent-tmp-demo\nspec:\n  accessModes:\n    - ReadWriteOnce\n  resources:\n    requests:\n      storage: 50Mi\n")),(0,s.kt)("p",null,"deployment.yaml:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: apps/v1\nkind: Deployment\nmetadata:\n...\nspec:\n...\n  template:\n  ...\n    spec:\n    ...\n      containers:\n      ...\n        - name: ...\n          volumeMounts:\n          ...\n            - name: pv-tmp-demo\n              readOnly: false\n              mountPath: /tmp/demo\n      volumes:\n        ...\n        - name: pv-tmp-demo\n          persistentVolumeClaim:\n            claimName: pvc-persistent-tmp-demo\n...\n")),(0,s.kt)("h3",{id:"persistent-volumes-in-statefulsets"},"Persistent volumes in statefulSet(s)"),(0,s.kt)("p",null,"When an application has multiple replicas, like in case of a statefulSet, volumeClaimTemplates should be used instead of persistentVolumeClaims.\nA volumeClaimTemplate will create PVCs for each replica of the application."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-yaml"},'apiVersion: apps/v1\nkind: StatefulSet\nmetadata:\n  name: web\nspec:\n  selector:\n    matchLabels:\n      app: nginx # has to match .spec.template.metadata.labels\n  serviceName: "nginx"\n  replicas: 3 # by default is 1\n  minReadySeconds: 10 # by default is 0\n  template:\n    metadata:\n      labels:\n        app: nginx # has to match .spec.selector.matchLabels\n    spec:\n      terminationGracePeriodSeconds: 10\n      containers:\n      - name: nginx\n        image: k8s.gcr.io/nginx-slim:0.8\n        ports:\n        - containerPort: 80\n          name: web\n        volumeMounts:\n        - name: www\n          mountPath: /usr/share/nginx/html\n  volumeClaimTemplates:\n  - metadata:\n      name: www\n    spec:\n      accessModes: [ "ReadWriteOnce" ]\n      storageClassName: "my-storage-class"\n      resources:\n        requests:\n          storage: 1Gi\n')),(0,s.kt)("admonition",{type:"tip"},(0,s.kt)("p",{parentName:"admonition"},"See this in action in our demo project, PVC example:\n",(0,s.kt)("a",{parentName:"p",href:"https://github.com/catenax-ng/k8s-helm-example/blob/main/charts/k8s-helm-example/templates/persistentVolumeClaim.yaml"},"persistentVolumeClaim.yaml"),"\n",(0,s.kt)("a",{parentName:"p",href:"https://github.com/catenax-ng/k8s-helm-example/blob/main/charts/k8s-helm-example/templates/deployment.yaml"},"deployment.yaml"))),(0,s.kt)("h3",{id:"defining-dependencies-that-use-persistent-volume-claims"},"Defining dependencies that use persistent volume claims"),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://github.com/catenax-ng/product-bpdm/blob/develop/helm/bpdm/Chart.yaml"},"Product BPDM")),(0,s.kt)("p",null,"Two dependencies are defined, elasticsearch and postgresql, both of them use persistent volume claims to store their data."),(0,s.kt)("p",null,"For further information on how to define dependencies, please refer to this documentation"),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://catenax-ng.github.io/docs/guides/how-to-helm-dependency"},"How to define Helm chart dependencies")),(0,s.kt)("h3",{id:"defining-persistent-volume-claims"},"Defining persistent volume claims"),(0,s.kt)("p",null,"If you define this PostgreSQL Helm chart as dependency for your application's Helm chart, it will create a PVC, as defined, Kubernetes will create a Persistent Volume (PV) for this PVC and the storage controller will create storage with the configured - or default if not configured - storage class."),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://github.com/bitnami/charts/blob/master/bitnami/postgresql/templates/primary/statefulset.yaml"},"StatefulSet in Postgres Helm chart")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-yaml"},'  {{- if and .Values.primary.persistence.enabled .Values.primary.persistence.existingClaim }}\n        - name: data\n          persistentVolumeClaim:\n            claimName: {{ tpl .Values.primary.persistence.existingClaim $ }}\n  {{- else if not .Values.primary.persistence.enabled }}\n        - name: data\n          emptyDir: {}\n  {{- else }}\n  volumeClaimTemplates:\n    - metadata:\n        name: data\n        {{- if .Values.primary.persistence.annotations }}\n        annotations: {{- toYaml .Values.primary.persistence.annotations | nindent 10 }}\n        {{- end }}\n      spec:\n        accessModes:\n        {{- range .Values.primary.persistence.accessModes }}\n          - {{ . | quote }}\n        {{- end }}\n        {{- if .Values.primary.persistence.dataSource }}\n        dataSource: {{- include "common.tplvalues.render" (dict "value" .Values.primary.persistence.dataSource "context" $) | nindent 10 }}\n        {{- end }}\n        resources:\n          requests:\n            storage: {{ .Values.primary.persistence.size | quote }}\n        {{- if .Values.primary.persistence.selector }}\n        selector: {{- include "common.tplvalues.render" (dict "value" .Values.primary.persistence.selector "context" $) | nindent 10 }}\n        {{- end }}\n        {{- include "common.storage.class" (dict "persistence" .Values.primary.persistence "global" .Values.global) | nindent 8 }}\n  {{- end }}\n')),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://github.com/bitnami/charts/blob/master/bitnami/postgresql/values.yaml"},"Values file for Postgres Helm chart")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-yaml"},'  ## PostgreSQL Primary persistence configuration\n  ##\n  persistence:\n    ## @param primary.persistence.enabled Enable PostgreSQL Primary data persistence using PVC\n    ##\n    enabled: true\n    ## @param primary.persistence.existingClaim Name of an existing PVC to use\n    ##\n    existingClaim: ""\n    ## @param primary.persistence.mountPath The path the volume will be mounted at\n    ## Note: useful when using custom PostgreSQL images\n    ##\n    mountPath: /bitnami/postgresql\n    ## @param primary.persistence.subPath The subdirectory of the volume to mount to\n    ## Useful in dev environments and one PV for multiple services\n    ##\n    subPath: ""\n    ## @param primary.persistence.storageClass PVC Storage Class for PostgreSQL Primary data volume\n    ## If defined, storageClassName: <storageClass>\n    ## If set to "-", storageClassName: "", which disables dynamic provisioning\n    ## If undefined (the default) or set to null, no storageClassName spec is\n    ##   set, choosing the default provisioner.  (gp2 on AWS, standard on\n    ##   GKE, AWS & OpenStack)\n    ##\n    storageClass: ""\n    ## @param primary.persistence.accessModes PVC Access Mode for PostgreSQL volume\n    ##\n    accessModes:\n      - ReadWriteOnce\n    ## @param primary.persistence.size PVC Storage Request for PostgreSQL volume\n    ##\n    size: 8Gi\n    ## @param primary.persistence.annotations Annotations for the PVC\n    ##\n    annotations: {}\n    ## @param primary.persistence.selector Selector to match an existing Persistent Volume (this value is evaluated as a template)\n    ## selector:\n    ##   matchLabels:\n    ##     app: my-app\n    ##\n    selector: {}\n    ## @param primary.persistence.dataSource Custom PVC data source\n    ##\n    dataSource: {}\n')),(0,s.kt)("admonition",{type:"tip"},(0,s.kt)("p",{parentName:"admonition"},"If no storage class is defined, the default on the Kubernetes cluster will be used.")),(0,s.kt)("h3",{id:"configuring-storage"},"Configuring storage"),(0,s.kt)("p",null,"The needs of the application can be different per use case, therefore it make sense to check the storage options of the cloud provider in use. For example a high I/O application will benefit from high performance SSD storage, in other cases when large amounts of data will be stored, high capacity HDD. You can customize this, as well as the size of your storage through helm chart variable(s), or custom values file(s)."))}c.isMDXComponent=!0}}]);